\chapter{Introduction and Concepts}

%---------------------------------------------------------------------------
\section{Introduction}

This chapter is an introduction to, the \accellat package which is part of the
greater \bmadjl ecosystem of toolkits and programs for accelerator simulations. With \accellat,
lattices can be constructed and manipulated. Essentially, a \vn{lattice} instance contains
a set of ``\vn{branches}'' and a branch contains 
an array of lattice \vn{elements} with each element representing an object like a magnet
or a RF cavity. A branch can be used to describe such
things as LINACs, storage rings, injection lines, X-ray beam lines, etc. Different branches in a
lattice can be connected together. For example, an injection line branch can be connected to a storage
ring branch or the lines of two rings can be connected together to form a colliding beam machine. 
This ability to describe the interconnections between branches means that 
a lattice instance can hold all the information about an entire machine complex from beam creation
to dump lines enabling a single lattice to be used as the basis of start-to-end simulations.

The sole purpose of the \accellat package is to implement methods for lattice construction.
Other stuff, like tracking and lattice analysis (for example, calculating
closed orbits and Twiss functions), is left to other packages in the \bmadjl ecosystem.

%---------------------------------------------------------------------------
\section{Documentation}

There are three main sources of documentation of the \accellat package. 
One source is this PDF manual which gives in-depth documentationon. 
A second source is the web based introduction and overview guide.
Finally, functions, structs and other objects are documented in the code files themselves. 
Taking advantage of Julia's built-in documentation system, this code-file documentation can be accessed
via using Julia's REPL.

%---------------------------------------------------------------------------
\section{Brief History}

\bmadjl has it's origins in the "Fortran \bmad" ecosystem of toolkits and programs developed over several
decades at Cornell University. Although the two share a similar name, the code of the two are
completely separate. That being said, the development of \accellat is heavily influenced by the 
experience --- both good and bad --- in the development and use of Fortran \bmad as well as experience
with other accelerator simulation programs.

The \julia language itself is used as the basis for constructing lattices with \accellat. 
Other simulation programs
have similarly utilized the underlying programming language for constructing 
lattices\cite{Appleby:Merlin2020,Iadarola:Xsuite2023}. This is in marked contrast to many accelerator
simulation programs such programs as MAD\cite{Grote:MAD1989}, Elegant\cite{Borland:Elegant2000}, and the 
\bmad toolkit\cite{Sagan:Bmad2006}. 
By using Julia for the lattice language, the user will automatically have access to such features 
as plotting, optimization packages, linear algebra packages, etc. 
This is a massive boost to the versatility and usability of any \bmadjl simulation program. 
Additionally, maintainability is greatly improved since the quantity of code that is needed is reduced.

%---------------------------------------------------------------------------------------------------
\section{Acknowledgements}

Thanks must go to the people who have contributed to this effort and without
whom \bmadjl would only be a shadow of what it is today: 

\'Etienne Forest (aka Patrice Nishikawa),
Matthew Signorelli,
Alexander Coxe,
Oleksii Beznosov,
Ryan Foussel,
Auralee Edelen,
Chris Mayes,
Georg Hoffstaetter,
Juan Pablo Gonzalez-Aguilera,
Scott Berg,
Dan Abell,
Laurent Deniau, and
Hugo Slepicka

%---------------------------------------------------------------------------
\section{Using AcceleratorLattice.jl}

\accellat is hosted on GitHub. The official repository is at
\begin{example}
  github.com/bmad-sim/AcceleratorLattice.jl
\end{example}
The \vn{README.md} file there has instructions on how to install \accellat.

A \vn{using} statement must be given before using \accellat in Julia
\begin{example}
  using AcceleratorLattice
\end{example}

%---------------------------------------------------------------------------
\section{Manual Conventions}
\label{s:manual.con}

This manual has the following conventions:
\begin{description}
%
\item[Types:]
\vn{Types} are also referred to as \vn{structs}.
%
\item[Type fields:]
\vn{Fields} of a type are also referred to as \vn{components} or \vn{parameters}.
A component \vn{c} of a type \vn{S} can be referred to as \vn{S.c}. In the case
of lattice elements, \vn{Ele} (the abstract type that all elements inherit from) is
used represent any of the subtypes such as \vn{Quadrupole}, etc. If the component
is an array, the notation \vn{S.c[]} can be used to emphasize this.
%
\end{description}


%---------------------------------------------------------------------------
\section{Lattice Elements}
\label{s:element.def}

The basic building block used to describe an accelerator is the lattice \vn{element}. An
element can be a physical thing that particles travel ``through'' like a bending magnet, a
quadrupole or a Bragg crystal, or something like a \vn{marker} element (\sref{s:mark}) that is used
to mark a particular point in the machine. Besides physical elements, there are \vn{controller},
elements that can be used for parameter control of other elements. All lattice elements are of types
that inherit from the abstract type \vn{Ele}.
Chapter~\sref{c:ele.types} lists the different element types that \bmad knows about.

%---------------------------------------------------------------------------
\section{Lattice Branches}
\label{s:branch.def}

The next level up from lattice \vn{elements} are the branches which
holds an array of lattice elements. A branch is of type \vn{Branch}. All
branches have a name \vn{Branch.name} inherited from the line that defines
the branch and branches contains an array of elements \vn{Branch.ele[]}

There are two types of \vn{branches}: branches whose \vn{Branch.type} parameter is set to
\vn{LordBranch} hold Lord elements and 
branches whose \vn{branch.type} parameter is set to \vn{TrackingBranch} is 

A tracking branch can represent a LINAC, X-Ray beam line, storage ring, etc.
For all tracking branches, the first element in the element array
must be of type \vn{BeginningEle} (\sref{s:begin.ele}).
Additionally, for all tracking branches, 
the end element must be of type \vn{Marker} (\sref{s:mark}).

%---------------------------------------------------------------------------
\section{Lattices}
\label{s:lattice.def}

All \vn{lattices} (\sref{s:lattice.def}) are of type \vn{Lat}.
A \vn{lattice}, has an array of \vn{branches} \vn{Lat.branch[]}. 
Tracking branches can be interconnected using \vn{fork} and \vn{photon_fork} elements (\sref{s:fork}). 
This is used to simulate forking beam lines such as a connections to a transfer line, dump line, or an
X-ray beam line. The \vn{branch} from which other \vn{branches} fork but is not forked to by any
other \vn{branch} is called a \vn{root} branch.

A lattice may contain multiple \vn{root} \vn{branches}. For example, a pair of intersecting storage
rings will generally have two \vn{root} branches, one for each ring.

%---------------------------------------------------------------------------
\section{AcceleratorLattice Conventions}
\label{s:conventions}

\accellat has the following conventions:
\begin{description}
%
\item[Evaluation is at upstream end:] 
For lattice element parameters that are s-dependent, the evaluation location is the
\vn{upstream} edge of the element (\sref{s:ref.construct}). These parameters include the 
element's global position, the reference energy/momentum, and the s-position.
%
\end{description}


%---------------------------------------------------------------------------
\section{Differences From Fortran Bmad}

Some differences between \accellat and Fortran \bmad to
be kept in mind when comparing the two:
\begin{description}
\item
Fortran \bmad is generally case insensitive (except for things like file names). \accellat, like
the Julia language, is case sensitive.
%
With Fortran \bmad, the branch array within a lattice and the element array within a branch is
indexed from zero. With \bmadjl, indexing of \vn{Lat.branch[]} and \vn{branch.ele[]} is 
from one conforming to the Julia standard.
%
\item
The Fortran \bmad names for the coordinate systems (\sref{s:coords}) was somewhat different and not
always consistent. The \vn{global} and \vn{element body} names are the same but \vn{machine}
coordinates are called the \vn{laboratory} in Fortran \bmad.
%
\item
Evaluation was at the downstream end (\sref{s:conventions}) in Fortran \bmad not the upstream end.
%
\item
With Fortran \bmad a value for any aperture limits of zero means the limit does not exist.
with \accellat a value of \vn{NaN} means the aperture does not exist. Additionally, with
Fortran \bmad a positive value for \vn{x1_limit} or \vn{y1_limit} meant that the aperture was
on the negative side of the \vn{x-axis} or \vn{y-axis} respectively. With \accellat, a positive
value for \vn{x_limit[1]} or \vn{y_limit[1]} means the aperture is on the positive side of 
of the \vn{x-axis} or \vn{y-axis} respectively. This makes the notation consistent across 
the different ways to specify apertures (compare with \vn{Mask} element syntax.).
%
\item
Fortran \bmad does not allow redefinition of named variables nor elements. \accellat allows this.
%
\item
With Fortran \bmad, the beginning and end elements are implicitly inserted into a branch line.
With \accellat, there is not implicit insertion. Also with Fortran \bmad the beginning element
is always named \vn{Beginning}. 
%
\end{description}



