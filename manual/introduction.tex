\chapter{Introduction and Concepts}

%---------------------------------------------------------------------------
\section{Introduction}

This chapter is an introduction to, the \accellat package which is part of the
greater \bmadjl ecosystem of toolkits and programs for accelerator simulations. With \accellat,
lattices can be constructed and manipulated. Essentially, a \vn{lattice} instance contains
a set of ``\vn{branches}'' and a branch contains 
an array of lattice \vn{elements} with each element representing an object like a magnet
or a RF cavity. A branch can be used to describe such
things as LINACs, storage rings, injection lines, X-ray beam lines, etc. Different branches in a
lattice can be connected together. For example, an injection line branch connected to a storage
ring branch or the lines of two ring connected together to form a colliding beam machine. 
This ability to describe the interconnections between branches means that 
a lattice instance can hold all the information about an entire machine complex from beam creation
to dump lines enabling a single lattice to be used as the basis of start-to-end simulations.

The sole purpose of the \accellat package is to implement methods for lattice construction.
Other stuff, like tracking and lattice analysis (for example, calculating
closed orbits and Twiss functions), is left to other packages in the \bmadjl ecosystem.

%---------------------------------------------------------------------------
\section{Documentation}

There are three main sources of documentation. One source is this pdf manual which gives in-depth
documentationon the \accellat package. A second source is the web based introduction and overview guide.
Finally, functions, structs and other objects are documented in the code files themselves. 
Taking advantage of Julia's built-in documentation system, this documentation can be accessed
when using Julia's REPL.

%---------------------------------------------------------------------------
\section{Brief History}

\bmadjl has it's origins in the "Fortran \bmad" ecosystem of toolkits and programs developed over several
decades at Cornell University. Although the two share a similar name, the code of the two are
completely separate. That being said, the development of \accellat was heavily influenced by the 
experience --- both good and bad --- in the development and use of Fortran \bmad as well as experience
with other accelerator simulation programs.

The \julia language itself is used as the basis for constructing lattices with \accellat. 
Other simulation programs
have similarly utilized the underlying programming language for constructing 
lattices\cite{Appleby:Merlin2020,Iadarola:Xsuite2023}. This is in marked contrast to many accelerator
simulation programs such programs as MAD\cite{Grote:MAD1989}, Elegant\cite{Borland:Elegant2000}, and the 
\bmad toolkit\cite{Sagan:Bmad2006}. 

By using Julia for the lattice language, the user will automatically have access to such features 
as plotting, optimization packages, linear algebra packages, etc. 
This is a massive boost to the versatility and usability of any \bmadjl simulation program. 
Additionally, maintainability is greatly improved since the quantity of code that is needed is reduced.

%---------------------------------------------------------------------------------------------------
\section{Acknowledgements}

It is my pleasure to express appreciation to people who have contributed to this effort, and without
whom, \bmadjl would only be a shadow of what it is today: 

\'Etienne Forest (aka Patrice Nishikawa),
Matthew Signorelli,
Alexander Coxe,
Oleksii Beznosov,
Ryan Foussel,
Auralee Edelen,
Chris Mayes,
Georg Hoffstaetter,
Juan Pablo Gonzalez-Aguilera,
Scott Berg,
Dan Abell,
Laurent Deniau, and
Hugo Slepicka

%---------------------------------------------------------------------------
\section{Using AcceleratorLattice.jl}

\accellat is hosted on GitHub. The official repository is at
\begin{example}
  github.com/bmad-sim/AcceleratorLattice.jl
\end{example}
The \vn{README.md} file there has instructions on how to install \accellat.

A \vn{using} statement must be given before using \accellat in Julia
\begin{example}
  using AcceleratorLattice
\end{example}

%---------------------------------------------------------------------------
\section{Lattice Elements}
\label{s:element.def}

The basic building block used to describe an accelerator is the lattice \vn{element}. An
element can be a physical thing that particles travel ``through'' like a bending magnet, a
quadrupole or a Bragg crystal, or something like a \vn{marker} element (\sref{s:mark}) that is used
to mark a particular point in the machine. Besides physical elements, there are \vn{controller},
elements that can be used for parameter control of other elements. All lattice elements are of types
that inherit from the abstract type \vn{Lat}.
Chapter~\sref{c:element-list} lists the complete set of different element types that \bmad knows about.

All lattice element structs hold a Dict named \vn{pdict} (parameter dict) which holds the element
parameters. For ease of manipulation, parameters are grouped into \vn{parameter} \vn{groups} structs.
and the values of \vn{pdict} will, with a few exceptions, be a parameter group. 
To hide the complexity of parameter groups, the dot selection operator is overloaded for elements
so something like \vn{q.s}, where \vn{q} is an element instance and \vn{s} is the parameter for the
element's longitudinal position, is mapped to \vn{q.pdict[:LengthGroup].s}.
This is discussed in detail in chapter~\sref{c:ele}.

%---------------------------------------------------------------------------
\section{Lattice Branches}
\label{s:branch.def}

The next level up from lattice \vn{elements} is the \vn{Branch} struct which
holds an array of lattice elements.
There are two types of branches.


There

\vn{branch} contains an ordered sequence of lattice elements that a particle will travel through. A
branch can represent a LINAC, X-Ray beam line, storage ring or anything else that can be represented
as a simple ordered list of elements.

Chapter~\sref{c:sequence} shows how a \vn{branch} can be defined using \vn{line}s.

Branches can be interconnected using \vn{fork} elements (\sref{s:fork}). This
is used to simulate forking beam lines such as a connections to a transfer line, dump line, or an
X-ray beam line. A \vn{branch} from which other \vn{branches} fork but is not forked to by any
other \vn{branch} is called a \vn{root} branch. A branch that is forked to by some other branch
is called a \vn{downstream} branch.

There are two types of \vn{branches}: \vn{LordBranches} and \vn{TrackingBranches}, 
Branches whose \vn{Branch.type} are set to \vn{LordBranch}



In a lattice \vn{branch} (\sref{s:branch.def}), each element in the
ordered array of elements are assigned an \vn{element index}
starting from one. The first element in a branch array
is called \vn{beginning_ele} (\sref{s:begin.ele}).
This element is always included in every \vn{branch} \sref{s:branch.def} and is used as a
marker for the beginning of the \vn{branch}.  Additionally, every branch will have a final
marker element (\sref{s:mark}) named \vn{end_ele}.

%---------------------------------------------------------------------------
\section{Lattices}
\label{s:lattice.def}

A \vn{lattice} (\sref{s:lattice.def}), has an array of \vn{branches}. 
Each \vn{branch} in this array
has a name an is assigned an index starting from one. 
Branches are named after the line that defines the \vn{branch}.

A \vn{lattice} contains an array of \vn{branches} that can be interconnected 
together to describe an entire machine
complex. A \vn{lattice} can include such things as transfer lines, dump lines, x-ray beam lines,
colliding beam storage rings, etc. All of which can be connected together to form a coherent whole. 
In addition, a lattice may contain \vn{controller elements} (Table~\ref{t:control.classes}) 
which can
simulate such things as magnet power supplies and support structures like a girder supporting
a section of magnets or an optical table supporting photonic elements.

Branches can be interconnected using \vn{fork} and \vn{photon_fork} elements (\sref{s:fork}). This
is used to simulate forking beam lines such as a connections to a transfer line, dump line, or an
X-ray beam line. The \vn{branch} from which other \vn{branches} fork but is not forked to by any
other \vn{branch} is called a \vn{root} branch.

A lattice may contain multiple \vn{root} \vn{branches}. For example, a pair of intersecting storage
rings will generally have two \vn{root} branches, one for each ring. The \vn{use} statement
(\sref{s:use}) in a lattice file will list the \vn{root} \vn{branches} of a lattice. To connect
together lattice elements that are physically shared between branches, for example, the interaction
region in colliding beam machines, \vn{multipass} lines (\sref{s:multipass}) can be used.

%---------------------------------------------------------------------------
\section{Conventions}
\label{s:conventions}

The following conventions 
\begin{description}
%
\item[Evaluation is at upstream end:] 
For lattice element parameters that are s-dependent, the evaluation location is the
\vn{upstream} edge of the element (\sref{s:ref.construct}). These parameters include the 
element's global position, the reference energy/momentum, and the s-position.
%
\end{description}


%---------------------------------------------------------------------------
\section{Differences From Fortran Bmad}

There are many differences between \accellat and Fortran \bmad but certain difference should
be kept in mind when comparing the two:
\begin{description}
\item
Fortran \bmad is generally case insensitive (except for things like file names). \accellat, like
the Julia language, is case sensitive.
%
\item
The Fortran \bmad names for the coordinate systems (\sref{s:coords}) was somewhat different and not
always consistent. The \vn{global} and \vn{element body} names are the same but \vn{machine}
coordinates are called the \vn{laboratory} in Fortran \bmad.
%
\item
Evaluation was at the downstream end (\sref{s:conventions}) in Fortran \bmad not the upstream end.
%
\item
With Fortran \bmad a value for any aperture limits of zero means the limit does not exist.
with \accellat a value of \vn{NaN} means the aperture does not exist. Additionally, with
Fortran \bmad a positive value for \vn{x1_limit} or \vn{y1_limit} meant that the aperture was
on the negative side of the \vn{x-axis} or \vn{y-axis} respectively. With \accellat, a positive
value for \vn{x_limit[1]} or \vn{y_limit[1]} means the aperture is on the positive side of 
of the \vn{x-axis} or \vn{y-axis} respectively. This makes the notation consistent across 
the different ways to specify apertures (compare with \vn{Mask} element syntax.).
\end{description}



